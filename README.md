I 2022
This file is a guide to the code underlying figures and results for Cook, Bull, Gomulkiewicz:  Gene drive escape from resistance depends on mechanism and ecology.  Several files of code are provided, each corresponding to a different figure. 
 
The files included contain the code necessary to generate the results shown in the figures (excluding fig. 4 which uses data generated by simple modifications of Figs 1 and 3 code).  The files don’t necessarily generate the complete set of data presented in figures, rather they generate data for subsets of figures and require the user to change input values to generate data for other parts of figures.  
 
The repository contains two directories.  ‘Data_output_names’ has with the code used to generate the figures other than Fig. 4. The second directory (basic_models) contains files of simpler code that can be used to generate data for individual cases or subsets of figures 1-3; these codes are likely the easiest to comprehend in understanding how the recursions operate.

Calculation methods:
The gene frequency recursions in these programs calculate offspring genotype numbers by exhaustive enumeration of all possible parental matings, multiplied by the fraction of gamete or offspring types produced by the parental genotypes.
As one example, in the code for 2 concurrent homing drives (fig1.c), the key recursion for transmission from (haploid) fathers to progeny is in a cluster of nested loops.  Neglecting braces that circumscribe the loops:
for(p1=0;p1<3;p1++) for(p2=0;p2<3;p2++) for(p3=0;p3<3;p3++)  // spans all possible genotypes across 3 diploid loci with allelic states p1, p2, p3
Y  = dipmales[p1][p2][p3];  // Frequency of a male of genotype p1 p2 p3 
z = mfec1[p1]*mfec2[p2];   // fitness of males of genotype p1 p2; p3 is irrelevant to fitness
for (o1 = 0; o1 < 2; o1++) for (o2 = 0; o2 < 2; o2++) for (o3 = 0; o3 < 2; o3++)     
	mg[o1][o2][o3] += tm1[RR][p1][o1] * tm2[RR][p2][o2] * ttt[p3][o3] * z * Y;

In this last nested loop, mg[][][] is the male progeny gamete genotype at 3 haploid loci (sperm).  tm1[][][] and tm2[][][] are drive transmission vectors conditioned on the resistance genotype of the father (RR, 0 or 1), the genotype at drive locus 1 or 2 in the father (p1, p2)) and the allele inherited by the progeny at that locus (o1 or o2).  The transmission vector ttt[][] is Mendelian.  The transmission vectors are trivially set at program initiation and ensure that progeny inherit only the parental alleles at Mendelian or drive frequencies -- tm1 and tm2 are specifically for drive, since we are assuming drive operates in males.  (The recursions for female gametes use transmission matrices that are Mendelian.)
Sib mating constitutes a second example.  In contrast to the 2-drive program, code for sib mating evolution (fig2.c) uses counts of mated (haploid) females. Under haploidy, a mated female’s state is represented by 4 indices The first index is her allele at the sib-mating locus, the second index is her allele at the drive locus, and the third and fourth indices are the same, respectively, for her sire.   With 2 alleles per locus, each element in the vector can take two states, 0 or 1.  Instead of transmission matrices, drive can be manifested simply by converting a (D,d) mated female mated into a (D,D) mated female, and likewise for a (d,D) mated female, where D is the drive allele and d its wild-type allele.  This shortcut is based on the mated female producing a brief diploid progeny intermediate that then becomes haploid according to the rules of segregation.  Fitness is assigned to the mated female (accruing to her progeny) based on what diploid progeny genotype she will produce, but fitness must be assigned before the code converts the drive locus (so that a Dd diploid is assigned the fitness for a heterozygote and not a DD homozygote).
Other programs follow similar rules.  

Output program method:
Programs to generate the figures take the underlying models and convert them into a function that runs the model with user specified initial conditions, until a specific condition is reached, for example fixation of the drive to a specified threshold or a specific number of generations. Then the relevant data are output to one or more .csv files. Function parameters are explained in the comments above the function declaration, or are named so as to be self-explanatory. The underlying model in these functions is the same as in the other code with a few modifications that do not change the underlying process, for example, code to stop the run once the drive has fixed, or code to reduce the population size to ¼ of its pervious number every five generations. 

Programs in the basic_models folder compile on Mac OSX 10.14 with 'gcc <filename> -lm'
	
The programs in the Data_output_programs directory were compiled on windows 10 using visual studio 2019.
	
The programs and their associated figures should be self-explanatory from the file names.  Note that figure 4 uses data from trivial modifications to the fig 1. and fig 3. programs.
	
	

